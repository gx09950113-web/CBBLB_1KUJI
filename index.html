<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>一番賞抽獎</title>
  <style>
    :root{
      --bg:#0b1020; --card:#111a33; --card2:#0f1730; --txt:#e9eeff; --muted:#a9b3d6;
      --ok:#4ade80; --warn:#fbbf24; --bad:#fb7185; --line:rgba(255,255,255,.12);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial;
      background: radial-gradient(1000px 500px at 20% 10%, rgba(99,102,241,.25), transparent 60%),
                  radial-gradient(900px 480px at 80% 30%, rgba(34,211,238,.18), transparent 60%),
                  var(--bg);
      color:var(--txt);
      min-height:100vh;
      display:flex; justify-content:center; padding:24px;
    }
    .wrap{width:min(980px,100%);}
    .hero{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:20px;
      box-shadow: var(--shadow);
      padding:18px 18px 14px;
      display:flex; gap:14px; align-items:flex-start; justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{margin:0 0 6px; font-size:20px; letter-spacing:.5px}
    .sub{margin:0; color:var(--muted); font-size:13px; line-height:1.5}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    input{
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--txt);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
      min-width:220px;
    }
    input:focus{border-color: rgba(99,102,241,.7); box-shadow: 0 0 0 3px rgba(99,102,241,.18)}
    button{
      cursor:pointer;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(99,102,241,.35), rgba(99,102,241,.18));
      color:var(--txt);
      padding:10px 14px;
      border-radius:12px;
      font-weight:600;
      letter-spacing:.2px;
      transition:.15s transform ease, .15s filter ease;
    }
    button:hover{filter:brightness(1.08)}
    button:active{transform:translateY(1px)}
    button.secondary{
      background: rgba(255,255,255,.06);
      font-weight:600;
    }
    button.danger{
      background: linear-gradient(180deg, rgba(251,113,133,.35), rgba(251,113,133,.18));
    }
    .grid{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 900px){ .grid{grid-template-columns:1fr} }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:20px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      background: rgba(0,0,0,.15);
    }
    .panel .bd{ padding:14px; }
    .tag{
      font-size:12px; color:var(--muted);
      padding:6px 10px; border:1px solid var(--line); border-radius:999px;
      background: rgba(255,255,255,.04);
    }

    /* 抽獎卡 */
    .reveal{
      display:grid; place-items:center;
      padding:20px 14px 22px;
      min-height:260px;
      background: radial-gradient(800px 380px at 50% 10%, rgba(99,102,241,.25), transparent 60%),
                  rgba(0,0,0,.12);
    }
    .card{
      width:min(520px,100%);
      border-radius:22px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: 0 25px 90px rgba(0,0,0,.6);
      overflow:hidden;
      transform-style:preserve-3d;
    }
    .card .face{
      padding:18px 18px 16px;
      display:flex; flex-direction:column; gap:10px;
    }
    .face .title{
      font-size:18px; font-weight:800; letter-spacing:.6px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .badge{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--muted);
      white-space:nowrap;
    }
    .big{
      font-size:28px; font-weight:900;
      line-height:1.1;
    }
    .desc{color:var(--muted); font-size:14px; line-height:1.55}
    .who{color:rgba(255,255,255,.9); font-weight:700}
    .flash{
      height:8px;
      background: linear-gradient(90deg, rgba(34,211,238,.0), rgba(34,211,238,.9), rgba(34,211,238,.0));
      filter: blur(.2px);
      opacity:.0;
    }

    /* 翻牌動畫 */
    .flip{
      animation: flip 900ms cubic-bezier(.2,.85,.2,1) both;
    }
    @keyframes flip{
      0%{transform: rotateY(0deg) scale(.98); filter:brightness(.9)}
      45%{transform: rotateY(90deg) scale(1.02); filter:brightness(1.05)}
      100%{transform: rotateY(0deg) scale(1); filter:brightness(1)}
    }
    .glow{
      animation: glow 1200ms ease-out both;
    }
    @keyframes glow{
      0%{box-shadow: 0 0 0 rgba(34,211,238,0)}
      35%{box-shadow: 0 0 80px rgba(34,211,238,.18)}
      100%{box-shadow: 0 0 0 rgba(34,211,238,0)}
    }
    .flash.on{ opacity:1; animation: flash 650ms ease-out both; }
    @keyframes flash{
      0%{transform:translateX(-60%); opacity:0}
      45%{opacity:1}
      100%{transform:translateX(60%); opacity:0}
    }

    /* 清單 */
    table{width:100%; border-collapse:separate; border-spacing:0}
    th,td{padding:10px 10px; font-size:13px; border-bottom:1px solid var(--line); text-align:left}
    th{color:var(--muted); font-weight:700; background: rgba(0,0,0,.10)}
    tr:last-child td{border-bottom:none}
    .pill{
      font-size:12px; font-weight:800;
      padding:4px 9px; border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
    }
    .pill.A{color:#fcd34d}
    .pill.B{color:#93c5fd}
    .pill.C{color:#86efac}
    .pill.D,.pill.E,.pill.F{color:#e5e7eb}
    .pill.LAST{color:#fb7185}

    .note{margin:10px 0 0; color:var(--muted); font-size:12px; line-height:1.5}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .hint{color:rgba(255,255,255,.85)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <div>
        <h1>一番賞抽獎（前端版）</h1>
        <p class="sub">
          填角色名 → 抽獎翻牌揭曉 → 自動扣庫。<span class="hint">最後賞固定第 31 抽才會出。</span><br>
          <span class="mono">資料會存在本機 localStorage</span>（重整不會消失）。
        </p>
      </div>
      <div class="row">
        <input id="playerName" placeholder="請輸入角色名字（必填）" maxlength="24" />
        <button id="drawBtn">抽一發！</button>
        <button class="secondary" id="exportBtn">匯出紀錄</button>
        <button class="secondary" id="resetBtn" title="會重置庫存與紀錄">重置整池</button>
      </div>
    </div>

    <div class="grid">
      <section class="panel">
        <div class="hd">
          <div style="display:flex; gap:10px; align-items:center;">
            <strong>翻牌揭曉</strong>
            <span class="tag" id="statusTag">剩餘 31 / 31</span>
          </div>
          <span class="tag" id="lastTag">最後賞：保留中</span>
        </div>
        <div class="reveal">
          <div class="card" id="revealCard" aria-live="polite">
            <div class="flash" id="flashBar"></div>
            <div class="face">
              <div class="title">
                <span>等待抽獎</span>
                <span class="badge" id="drawMeta">尚未抽出</span>
              </div>
              <div class="big" id="prizeBig">—</div>
              <div class="desc" id="prizeDesc">
                請先輸入角色名字，然後按「抽一發！」<br>
                抽到的獎項會從池子移除，不會重複。
              </div>
              <div class="desc">抽獎者：<span class="who" id="whoText">（尚未）</span></div>
            </div>
          </div>
        </div>
        <div class="bd">
          <p class="note">
            小提醒：純前端版不防作弊（可清 localStorage / 改 JS）。要防作弊建議改成後端/表單儲存。
          </p>
        </div>
      </section>

      <section class="panel">
        <div class="hd">
          <strong>庫存與紀錄</strong>
          <span class="tag" id="poolTag">獎池就緒</span>
        </div>
        <div class="bd" style="padding:0">
          <table>
            <thead>
              <tr>
                <th style="width:82px;">類別</th>
                <th>獎項</th>
                <th style="width:70px;">剩餘</th>
              </tr>
            </thead>
            <tbody id="poolTable"></tbody>
          </table>
        </div>
        <div class="bd">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
            <span class="tag" id="logTag">已抽 0 人</span>
            <button class="danger" id="undoBtn" title="回復上一抽（主持人救援用）">撤回上一抽</button>
          </div>
          <div class="note" id="lastLogNote" style="margin-top:8px;"></div>
        </div>
      </section>
    </div>
  </div>

<script>
/**
 * 一番賞抽獎（純前端）
 * - 31 個名額：其中「最後賞」保留到最後一抽
 * - 其餘 30 個名額按權重（實際名額數）隨機抽
 * - 會存 localStorage：庫存、已抽紀錄、已用角色名（避免重複抽）
 */

const STORAGE_KEY = "ichiban_lottery_v1";

const PRIZES = [
  { key: "A", label: "A賞", desc: "2580時裝 × 1套", count: 1 },
  { key: "B", label: "B賞", desc: "1280時裝 × 2套", count: 2 },
  { key: "C", label: "C賞", desc: "680時裝 × 3套",  count: 3 },
  { key: "D", label: "D賞", desc: "300長鳴珠 × 5位", count: 5 },
  { key: "E", label: "E賞", desc: "180長鳴珠 × 10位", count: 10 },
  { key: "F", label: "F賞", desc: "60長鳴珠 × 10位",  count: 10 },
  // 最後賞單獨處理：第 31 抽一定給
  { key: "LAST", label: "最後賞", desc: "3000長鳴珠 × 1位（最後一抽才會出）", count: 1, isLast: true },
];

function buildInitialState(){
  // 建立 30 個「一般獎」名額池（A~F） + lastReserved = true
  const pool = {};
  for (const p of PRIZES) pool[p.key] = p.count;

  return {
    pool, // 各類剩餘
    logs: [], // {idx, name, prizeKey, prizeLabel, prizeDesc, at}
    usedNames: {}, // name -> true（避免同名重複抽）
    createdAt: new Date().toISOString(),
  };
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return buildInitialState();
    const st = JSON.parse(raw);
    // 基本補齊
    if(!st.pool || !st.logs || !st.usedNames) return buildInitialState();
    return st;
  }catch(e){
    return buildInitialState();
  }
}

function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function totalRemaining(){
  return Object.values(state.pool).reduce((a,b)=>a+b,0);
}

function totalAll(){
  return PRIZES.reduce((a,p)=>a+p.count,0);
}

function remainingNonLast(){
  return Object.entries(state.pool)
    .filter(([k]) => k !== "LAST")
    .reduce((a,[,v]) => a+v, 0);
}

function nowFmt(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}

// 把 A~F 的剩餘名額攤平成「抽籤籤筒」
function buildTicketsNonLast(){
  const tickets = [];
  for (const p of PRIZES){
    if(p.key === "LAST") continue;
    const left = state.pool[p.key] || 0;
    for(let i=0;i<left;i++) tickets.push(p.key);
  }
  return tickets;
}

function pickRandom(arr){
  const i = Math.floor(Math.random()*arr.length);
  return arr[i];
}

function prizeInfo(key){
  const p = PRIZES.find(x=>x.key===key);
  return p ? p : { key, label:key, desc:"" };
}

// DOM
const $ = (id)=>document.getElementById(id);
const playerName = $("playerName");
const drawBtn = $("drawBtn");
const exportBtn = $("exportBtn");
const resetBtn = $("resetBtn");
const undoBtn = $("undoBtn");

const statusTag = $("statusTag");
const lastTag = $("lastTag");
const poolTag = $("poolTag");
const poolTable = $("poolTable");
const logTag = $("logTag");
const lastLogNote = $("lastLogNote");

const revealCard = $("revealCard");
const flashBar = $("flashBar");
const drawMeta = $("drawMeta");
const prizeBig = $("prizeBig");
const prizeDesc = $("prizeDesc");
const whoText = $("whoText");

// state
let state = loadState();
renderAll();

function renderAll(){
  renderStatus();
  renderPoolTable();
  renderLogsSummary();
  renderButtonsState();
}

function renderStatus(){
  const rem = totalRemaining();
  statusTag.textContent = `剩餘 ${rem} / ${totalAll()}`;

  const lastLeft = state.pool["LAST"] || 0;
  if(lastLeft === 1){
    lastTag.textContent = `最後賞：保留中（最後一抽）`;
  }else{
    lastTag.textContent = `最後賞：已抽出`;
  }

  if(rem === 0){
    poolTag.textContent = "獎池已抽完";
  }else{
    poolTag.textContent = "獎池進行中";
  }
}

function renderPoolTable(){
  poolTable.innerHTML = "";
  for (const p of PRIZES){
    const left = state.pool[p.key] ?? 0;
    const tr = document.createElement("tr");

    const td1 = document.createElement("td");
    const pill = document.createElement("span");
    pill.className = `pill ${p.key}`;
    pill.textContent = p.label;
    td1.appendChild(pill);

    const td2 = document.createElement("td");
    td2.textContent = p.desc;

    const td3 = document.createElement("td");
    td3.textContent = left;

    tr.append(td1, td2, td3);
    poolTable.appendChild(tr);
  }
}

function renderLogsSummary(){
  logTag.textContent = `已抽 ${state.logs.length} 人`;
  const last = state.logs[state.logs.length - 1];
  if(!last){
    lastLogNote.textContent = "尚未有人抽獎。";
    return;
  }
  lastLogNote.innerHTML = `
    上一抽：<span class="mono">${escapeHtml(last.name)}</span> → 
    <span class="pill ${last.prizeKey}">${escapeHtml(last.prizeLabel)}</span>
    <span class="mono">（#${last.idx}）</span><br>
    <span class="note mono">${escapeHtml(last.at)}</span>
  `;
}

function renderButtonsState(){
  const rem = totalRemaining();
  drawBtn.disabled = rem === 0;
  undoBtn.disabled = state.logs.length === 0;
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}

function animateReveal(){
  revealCard.classList.remove("flip","glow");
  flashBar.classList.remove("on");
  // 觸發 reflow
  void revealCard.offsetWidth;
  revealCard.classList.add("flip","glow");
  flashBar.classList.add("on");
}

function normalizeName(name){
  return name.trim().replace(/\s+/g," ");
}

function canDraw(name){
  if(!name) return { ok:false, msg:"請先輸入角色名字。" };
  if(name.length < 2) return { ok:false, msg:"角色名字太短啦（至少 2 字）。" };
  if(state.usedNames[name]) return { ok:false, msg:"這個角色名已抽過了（避免重複抽）。" };
  if(totalRemaining() <= 0) return { ok:false, msg:"獎池已抽完。" };
  return { ok:true };
}

function doDraw(name){
  const rem = totalRemaining();
  const drawIndex = state.logs.length + 1; // 1..31

  // 若只剩最後賞 -> 直接給
  const lastLeft = state.pool["LAST"] || 0;
  const nonLastLeft = remainingNonLast();

  let prizeKey;

  // 規則：最後賞保留到第 31 抽
  if(drawIndex === totalAll()){
    prizeKey = "LAST";
  } else {
    // 其他時候不能抽到 LAST
    if(nonLastLeft <= 0){
      // 理論上不會發生（因為最後賞保留到第31抽），但加保護
      prizeKey = "LAST";
    } else {
      const tickets = buildTicketsNonLast();
      prizeKey = pickRandom(tickets);
    }
  }

  // 扣庫
  state.pool[prizeKey] = (state.pool[prizeKey] || 0) - 1;
  if(state.pool[prizeKey] < 0) state.pool[prizeKey] = 0;

  const info = prizeInfo(prizeKey);
  const log = {
    idx: drawIndex,
    name,
    prizeKey,
    prizeLabel: info.label,
    prizeDesc: info.desc,
    at: nowFmt(),
  };

  state.logs.push(log);
  state.usedNames[name] = true;
  saveState();

  return log;
}

function showReveal(log){
  drawMeta.textContent = `第 #${log.idx} 抽`;
  prizeBig.textContent = `${log.prizeLabel}！`;
  prizeDesc.textContent = log.prizeDesc;
  whoText.textContent = log.name;

  animateReveal();
}

drawBtn.addEventListener("click", ()=>{
  const name = normalizeName(playerName.value);
  const ok = canDraw(name);
  if(!ok.ok){
    // 直接用卡片區顯示錯誤
    drawMeta.textContent = "無法抽獎";
    prizeBig.textContent = "—";
    prizeDesc.textContent = ok.msg;
    whoText.textContent = name || "（未填）";
    animateReveal();
    return;
  }

  const log = doDraw(name);
  showReveal(log);
  renderAll();
  playerName.value = "";
  playerName.focus();
});

exportBtn.addEventListener("click", ()=>{
  const data = {
    exportedAt: new Date().toISOString(),
    state,
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `lottery_export_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
});

resetBtn.addEventListener("click", ()=>{
  if(!confirm("確定要重置整池？（庫存與紀錄都會清空）")) return;
  state = buildInitialState();
  saveState();

  drawMeta.textContent = "尚未抽出";
  prizeBig.textContent = "—";
  prizeDesc.textContent = "已重置。請輸入角色名字後再抽。";
  whoText.textContent = "（尚未）";
  animateReveal();

  renderAll();
});

undoBtn.addEventListener("click", ()=>{
  const last = state.logs.pop();
  if(!last) return;

  // 回補庫存
  state.pool[last.prizeKey] = (state.pool[last.prizeKey] || 0) + 1;

  // 回收名字使用權（只要該名字不在其他紀錄裡）
  const stillUsed = state.logs.some(x => x.name === last.name);
  if(!stillUsed) delete state.usedNames[last.name];

  saveState();

  drawMeta.textContent = "已撤回上一抽";
  prizeBig.textContent = "—";
  prizeDesc.textContent = `已撤回：${last.name}（第 #${last.idx} 抽）`;
  whoText.textContent = "（尚未）";
  animateReveal();

  renderAll();
});

// Enter 直接抽
playerName.addEventListener("keydown", (e)=>{
  if(e.key === "Enter") drawBtn.click();
});
</script>
</body>
</html>
